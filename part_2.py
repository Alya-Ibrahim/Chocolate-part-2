# -*- coding: utf-8 -*-
"""part-2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lCjF_Bd8mI-CYhqCt6VgZS-Y0wjKTGiQ
"""

from pprint import pprint

#Here we are defining the quick sort function
def quick_sort(arr, key):
    # Base case: if the list has 1 or 0 elements, then this means that it is already sorted
    if len(arr) <= 1:
        return arr
    pivot = arr[-1]  # Choose the last element as the pivot for simplicity
    # Partitions for elements less than, equal to, and greater than the pivot
    less = [x for x in arr[:-1] if x[key] <= pivot[key]]
    more = [x for x in arr[:-1] if x[key] > pivot[key]]
    # Recursively apply Quick Sort on partitions and combine with pivot for final list
    return quick_sort(less, key) + [pivot] + quick_sort(more, key)

#Here we are defining the merge sort function
def merge_sort(arr, key):
    # Base case: if the list has 1 or 0 elements, then this means that it is already sorted
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2  #here it finds the midpoint of the list
    # Recursively applies the Merge Sort on each half of the list
    L = merge_sort(arr[:mid], key)
    R = merge_sort(arr[mid:], key)
    #here it merges the two sorted halves
    return merge(L, R, key)

#here it defines the merge function to combine the two sorted lists
def merge(L, R, key):
    sorted_list = []  #it first initializes an empty list to hold the merged result
    # Indices for iterating through the two halves
    left_index, right_index = 0, 0
    #A while loop is used to loop until we reach the end of either left half or right half
    while left_index < len(L) and right_index < len(R):
        #it appends the smaller element to the sorted_list
        if L[left_index][key] <= R[right_index][key]:
            sorted_list.append(L[left_index])
            left_index += 1
        else:
            sorted_list.append(R[right_index])
            right_index += 1
    #here what it does is that once one half is exhausted, it appends the remaining elements from the other half
    sorted_list.extend(L[left_index:])
    sorted_list.extend(R[right_index:])
    return sorted_list

#this part is the test cases where I did four test cases
test_cases = {
    "varied_weights_and_prices": [
        {'weight': 10, 'price': 5, 'type': 'Dark', 'ID': '004'},
        {'weight': 5, 'price': 3, 'type': 'Milk', 'ID': '001'},
        {'weight': 7, 'price': 4, 'type': 'White', 'ID': '003'},
        {'weight': 6, 'price': 6, 'type': 'Hazelnut', 'ID': '002'},
    ],
    "same_weights_different_prices": [
        {'weight': 5, 'price': 5, 'type': 'Dark', 'ID': '004'},
        {'weight': 5, 'price': 3, 'type': 'Milk', 'ID': '001'},
        {'weight': 5, 'price': 4, 'type': 'White', 'ID': '003'},
        {'weight': 5, 'price': 6, 'type': 'Hazelnut', 'ID': '002'},
    ],
    "different_weights_same_prices": [
        {'weight': 10, 'price': 4, 'type': 'Dark', 'ID': '004'},
        {'weight': 5, 'price': 4, 'type': 'Milk', 'ID': '001'},
        {'weight': 7, 'price': 4, 'type': 'White', 'ID': '003'},
        {'weight': 6, 'price': 4, 'type': 'Hazelnut', 'ID': '002'},
    ],
    "reverse_order": [
        {'weight': 9, 'price': 6, 'type': 'Dark', 'ID': '004'},
        {'weight': 8, 'price': 5, 'type': 'Milk', 'ID': '001'},
        {'weight': 3, 'price': 2, 'type': 'White', 'ID': '003'},
        {'weight': 1, 'price': 1, 'type': 'Hazelnut', 'ID': '002'},
    ]
}

#It sorts the chocolates for each test case
sorted_results = {}
for case, chocolates in test_cases.items():
    #It uses Quick Sort to sort by weight
    sorted_by_weight = quick_sort(chocolates.copy(), 'weight')
    #It uses Merge Sort to sort by price
    sorted_by_price = merge_sort(chocolates.copy(), 'price')
    # Store the sorted results in a dictionary
    sorted_results[case] = {
        "sorted_by_weight": sorted_by_weight,
        "sorted_by_price": sorted_by_price
    }

#It prints the sorted results for each test case
for case, results in sorted_results.items():
    print(f"Test Case: {case}")
    print("Sorted by Weight (Quick Sort):")
    # Pretty-print the list sorted by weight
    pprint(results["sorted_by_weight"])
    print("Sorted by Price (Merge Sort):")
    # Pretty-print the list sorted by price
    pprint(results["sorted_by_price"])
    print("\n")  # Add an empty line for better readability between test cases because this will add a space between them so the test cases can show clearly